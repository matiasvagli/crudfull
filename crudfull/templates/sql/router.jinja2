from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List

from .schemas import {{ model_name }}Create, {{ model_name }}Update, {{ model_name }}Response
from .service import {{ model_name }}Service
from .repository import {{ model_name }}Repository

# Import get_db from the project's database configuration
try:
    from app.db.session import get_db
except ImportError:
    # Fallback for different project structures
    try:
        from database import get_db
    except ImportError:
        from ...database_examples.database_sql_example import get_db

router = APIRouter(prefix="/{{ resource }}", tags=["{{ model_name }}"])

@router.get("/", response_model=List[{{ model_name }}Response])
async def list_{{ resource }}(db: AsyncSession = Depends(get_db)):
    repository = {{ model_name }}Repository(db)
    service = {{ model_name }}Service(repository)
    return await service.list()

@router.get("/{id}", response_model={{ model_name }}Response)
async def read_{{ singular }}(id: int, db: AsyncSession = Depends(get_db)):
    repository = {{ model_name }}Repository(db)
    service = {{ model_name }}Service(repository)
    item = await service.read(id)
    if not item:
        raise HTTPException(status_code=404, detail="Item not found")
    return item

@router.post("/", response_model={{ model_name }}Response)
async def create_{{ singular }}(
    item: {{ model_name }}Create,
    db: AsyncSession = Depends(get_db)
):
    repository = {{ model_name }}Repository(db)
    service = {{ model_name }}Service(repository)
    return await service.create(item)

@router.patch("/{id}", response_model={{ model_name }}Response)
async def update_{{ singular }}(id: int, item: {{ model_name }}Update, db: AsyncSession = Depends(get_db)):
    repository = {{ model_name }}Repository(db)
    service = {{ model_name }}Service(repository)
    updated = await service.update(id, item)
    if not updated:
        raise HTTPException(status_code=404, detail="Item not found")
    return updated

@router.delete("/{id}", response_model={{ model_name }}Response)
async def delete_{{ singular }}(id: int, db: AsyncSession = Depends(get_db)):
    repository = {{ model_name }}Repository(db)
    service = {{ model_name }}Service(repository)
    deleted = await service.delete(id)
    if not deleted:
        raise HTTPException(status_code=404, detail="Item not found")
    return deleted
